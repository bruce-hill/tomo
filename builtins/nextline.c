// An enum used for iterating over lines in a file
// Most of the code here was generated by compiling:
//    enum NextLine(Done, Next(line:Text))

#include <stdbool.h>
#include <stdint.h>

#include "siphash.h"
#include "datatypes.h"
#include "nextline.h"
#include "text.h"
#include "util.h"

static Text_t NextLine$Next$as_text(NextLine$Next_t *obj, bool use_color)
{
    if (!obj)
        return Text("Next");
    return Text$concat(use_color ? Text("\x1b[0;1mNext\x1b[m(") : Text("Next("), Text("line="),
                       Text$as_text((Text_t[1]){obj->$line}, use_color, &Text$info), Text(")"));
}

public inline NextLine_t NextLine$tagged$Next(Text_t $line)
{
    return (NextLine_t) {
        .tag = NextLine$tag$Next,.$Next = { $line }
    };
}

static Text_t NextLine$as_text(NextLine_t *obj, bool use_color)
{
    if (!obj)
        return Text("NextLine");
    switch (obj->tag) {
    case NextLine$tag$Done:
        return use_color ? Text("\x1b[36;1mNextLine.Done\x1b[m") : Text("NextLine.Done");
    case NextLine$tag$Next:
        return Text$concat(use_color ? Text("\x1b[36;1mNextLine.Next\x1b[m(") :
                           Text("NextLine.Next("), Text("line="),
                           Text$as_text((Text_t[1]){obj->$Next.$line}, use_color, &Text$info), Text(")"));
    default:
        return (Text_t) {
        .length = 0};
    }
}

static bool NextLine$equal(const NextLine_t *x, const NextLine_t *y,
                               const TypeInfo *info)
{
    (void) info;
    if (x->tag != y->tag)
        return false;
    switch (x->tag) {
    case NextLine$tag$Done:
        return false;
    case NextLine$tag$Next:
        return generic_equal(&x->$Next, &y->$Next, (&NextLine$Next));
    default:
        return 0;
    }
}

static int NextLine$compare(const NextLine_t *x, const NextLine_t *y,
                                const TypeInfo *info)
{
    (void) info;
    int diff = (int)x->tag - (int)y->tag;
    if (diff)
        return diff;
    switch (x->tag) {
    case NextLine$tag$Done:
        return 0;
    case NextLine$tag$Next:
        return generic_compare(&x->$Next, &y->$Next, (&NextLine$Next));
    default:
        return 0;
    }
}

static uint64_t NextLine$hash(const NextLine_t *obj, const TypeInfo *info)
{
    (void) info;
    uint64_t hashes[2] = { (uint64_t) obj->tag, 0 };
    switch (obj->tag) {
    case NextLine$tag$Done:
        break;
    case NextLine$tag$Next:
        hashes[1] = generic_hash(&obj->$Next, (&NextLine$Next));
        break;
    default: break;
    }
    return siphash24((void *) &hashes, sizeof(hashes));
}

public const TypeInfo NextLine$Done = { 0, 0, {.tag = EmptyStruct,.EmptyStruct.name =
                                                   "NextLine$Done" } };
public const TypeInfo NextLine$Next = { 24, 8, {.tag = CustomInfo,.CustomInfo =
                                                    {.as_text =
                                                     (void *) NextLine$Next$as_text,.hash =
                                                     (void *) Text$hash,.compare =
                                                     (void *) Text$compare,.equal =
                                                     (void *) Text$equal,} } };
public const TypeInfo NextLine = { 32, 8, {.tag = CustomInfo,.CustomInfo =
                                               {.as_text = (void *) NextLine$as_text,.equal =
                                                (void *) NextLine$equal,.hash =
                                                (void *) NextLine$hash,.compare =
                                                (void *) NextLine$compare} } };

// vim: ts=4 sw=0 et cino=L2,l1,(0,W4,m1,\:0
